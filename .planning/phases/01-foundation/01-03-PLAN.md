---
phase: 01-foundation
plan: 03
type: execute
---

<objective>
Pre-compute dashboard-ready aggregations from the large JSON data files and create TypeScript types and data loaders.

Purpose: The enriched_master_index.json is 12MB — too large to bundle directly. Extract only what each view needs into smaller, focused JSON files. Create typed data access for all views.
Output: Pre-computed JSON data files in src/data/, TypeScript types, and loader utilities.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md

**Data files available (in project root):**
- `enriched_master_index.json` (12MB, 1,659 records) — master dataset with per-event financials, sections, labor roles
- `rate_card_master.json` (46KB, 136 roles) — small enough to use directly
- `financial_summary.json` (9.6KB) — pre-aggregated by client/office/segment/status — small enough to use directly
- `section_summary.json` (852B) — section usage stats — small enough to use directly

**Record structure (enriched_master_index.json):**
Each record has: client, event_name, lead_office, status, event_manager, revenue_segment, event_start_date, event_end_date, grand_total, sections (array with bid_total/recap_total per section), labor_roles (array with role/unit_rate/gl_code), has_recap_data, agency_fees, other_production_costs, and more.

**What each view needs:**
- **Dashboard Executive Summary**: Total events, total revenue, avg event size, top clients by revenue, top offices by volume, status distribution, events over time
- **Dashboard Cost Analysis**: Section-level cost breakdowns (bid vs actual), cost category distributions
- **Dashboard Bid vs Actual Variance**: Only the ~996 events with has_recap_data=true, variance calculations per event, aggregate variance by section/client/office
- **Dashboard Event Manager Performance**: Event count and total revenue per event manager, bid accuracy metrics
- **Rate Card Explorer**: rate_card_master.json directly (46KB is fine)
- **AI Scoping Assistant**: Summary stats for prompt context (computed at runtime from the pre-computed data)

**Key constraint from PROJECT.md:**
- Pre-compute where possible to keep bundle manageable
- enriched_master_index.json too large to embed raw
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create data pre-computation script</name>
  <files>scripts/precompute-data.ts, src/data/dashboard-executive.json, src/data/dashboard-costs.json, src/data/dashboard-variance.json, src/data/dashboard-managers.json, src/data/rate-card.json, src/data/ai-context.json</files>
  <action>
Create `scripts/precompute-data.ts` — a Node.js script (run with `npx tsx`) that reads the source JSON files and outputs focused aggregations to `src/data/`.

Add `tsx` as a dev dependency: `npm install -D tsx`

Add npm script: `"precompute": "tsx scripts/precompute-data.ts"`

The script should:

**1. Read source files:**
```ts
const masterIndex = JSON.parse(fs.readFileSync('enriched_master_index.json', 'utf-8'))
const rateCard = JSON.parse(fs.readFileSync('rate_card_master.json', 'utf-8'))
const financialSummary = JSON.parse(fs.readFileSync('financial_summary.json', 'utf-8'))
const sectionSummary = JSON.parse(fs.readFileSync('section_summary.json', 'utf-8'))
```

**2. Generate `src/data/dashboard-executive.json`:**
- totalEvents: number of records
- totalRevenue: sum of grand_total where grand_total > 0
- avgEventSize: totalRevenue / count of events with grand_total > 0
- medianEventSize: median of grand_total where > 0
- eventsWithRecap: count where has_recap_data === true
- topClientsByRevenue: top 10 clients by sum of grand_total (name, count, totalRevenue)
- topOfficesByVolume: all offices with event count and total revenue
- statusDistribution: count per status value
- revenueSegmentDistribution: count and total per revenue_segment
- eventsByMonth: array of {month: "YYYY-MM", count: number, revenue: number} for timeline chart (parse event_start_date)

**3. Generate `src/data/dashboard-costs.json`:**
- Copy financial_summary.json as-is (already small and pre-aggregated)
- Add section_summary.json data
- Add per-section aggregates from masterIndex: for each canonical section name, compute total bid, total actual (recap), avg bid, avg actual across all events that have that section

**4. Generate `src/data/dashboard-variance.json`:**
- Filter masterIndex to only records where has_recap_data === true
- For each event: compute per-section variance (recap_total - bid_total) and percentage
- Output:
  - summary: overall avg variance %, median variance %, count
  - bySection: per-section aggregate (avg variance, total over/under)
  - byClient: per-client variance summary (top overruns, top underruns)
  - byOffice: per-office variance summary
  - events: array of {event_name, client, grand_total_bid (sum of section bid_totals), grand_total_actual (sum of section recap_totals), variance, variancePct} — sorted by absolute variance descending, limited to top 50 for chart data

**5. Generate `src/data/dashboard-managers.json`:**
- Group masterIndex by event_manager (skip null/empty)
- Per manager: event count, total revenue (sum of grand_total), avg event size, clients served (unique client names), events with recap data count
- If manager has recap events: compute avg bid accuracy (recap_total / bid_total ratio across their events)
- Sort by event count descending

**6. Copy `src/data/rate-card.json`:**
- Copy rate_card_master.json directly (already 46KB and the right shape)

**7. Generate `src/data/ai-context.json`:**
- Summary stats for the AI prompt context: total events, date range, top sections with avg costs, common roles with rate ranges, revenue segments, avg event size by segment
- Keep small — this gets embedded in the Claude prompt

Print file sizes after generation so we can verify bundle impact.
  </action>
  <verify>
Run `npm run precompute` — script completes without errors, prints file sizes.
Verify all 6 JSON files exist in `src/data/`.
Verify total size of `src/data/` is under 500KB (should be well under).
Run `npm run build` — Vite bundles successfully with the data files.
  </verify>
  <done>
Six pre-computed JSON files in src/data/ with focused aggregations for each view. Total data size is manageable for bundling. Build succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TypeScript types and data loader utilities</name>
  <files>src/types/dashboard.ts, src/types/rate-card.ts, src/types/ai-context.ts, src/lib/data.ts</files>
  <action>
Create TypeScript type definitions matching the pre-computed data shapes:

`src/types/dashboard.ts`:
- ExecutiveSummary: totalEvents, totalRevenue, avgEventSize, medianEventSize, eventsWithRecap, topClientsByRevenue, topOfficesByVolume, statusDistribution, revenueSegmentDistribution, eventsByMonth
- CostAnalysis: grandTotalRanges, filesBidAndRecap, byRevenueSegment, byClient, byLeadOffice, byStatus, sectionSummary, sectionAggregates
- VarianceData: summary, bySection, byClient, byOffice, events (array of variance records)
- ManagerData: array of {name, eventCount, totalRevenue, avgEventSize, clientsServed, recapEventCount, avgBidAccuracy}

`src/types/rate-card.ts`:
- RateCardRole: role, glCodes, occurrences, hasOtVariant, unitRateRange (min/max/avg/median), costRateRange

`src/types/ai-context.ts`:
- AIContext: totalEvents, dateRange, sections, commonRoles, revenueSegments, avgEventSizeBySegment

`src/lib/data.ts`:
- Import and re-export the JSON data with proper typing
- Use TypeScript `import` for JSON files (Vite handles this natively):
  ```ts
  import executiveData from '@/data/dashboard-executive.json'
  import costsData from '@/data/dashboard-costs.json'
  import varianceData from '@/data/dashboard-variance.json'
  import managersData from '@/data/dashboard-managers.json'
  import rateCardData from '@/data/rate-card.json'
  import aiContextData from '@/data/ai-context.json'
  ```
- Export typed accessor functions:
  ```ts
  export function getExecutiveSummary(): ExecutiveSummary { return executiveData as ExecutiveSummary }
  export function getCostAnalysis(): CostAnalysis { return costsData as CostAnalysis }
  // etc.
  ```

Verify JSON imports work by adding a temporary test in a page stub — e.g., display totalEvents count on the DashboardPage.
  </action>
  <verify>
Run `npm run build` — no TypeScript errors.
Run `npm run dev` — DashboardPage shows the totalEvents count from pre-computed data.
  </verify>
  <done>
TypeScript types match all pre-computed data shapes. Data loader utilities export typed accessors. JSON imports work through Vite. Build succeeds with no type errors. Dashboard stub displays real data count.
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run precompute` generates all 6 JSON files without errors
- [ ] Total src/data/ size is under 500KB
- [ ] `npm run build` succeeds with no TypeScript errors
- [ ] All types are defined and match data shapes
- [ ] JSON imports work via `@/data/` path alias
- [ ] At least one page stub displays real data to prove the pipeline works end-to-end
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- Pre-computed data is small enough for browser bundling
- Data pipeline is reproducible via `npm run precompute`
- Phase 1 Foundation complete — ready for Phase 2 (Dashboard & Rate Card views)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`

This is the final plan of Phase 1. Success criteria should include:
- "Phase 1: Foundation complete"
- All three plans executed successfully
- Project scaffolded, navigation shell working, data pipeline producing component-ready JSON
</output>
